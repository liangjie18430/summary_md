a. 样本与任务加权
考虑到我们业务对不同任务有不同的侧重，我们首先对每个任务自定义一个加权的权重融合到loss中。
考虑到用户的观看时长对当前样本的置信度影响较大，我们用观看时长对样本做了一个加权。
由于有些任务的数据相对比较稀疏，比如关注、送花等。而我们的主目标的训练样本有些是有全局负采样的样本，这样就使得这些子任务正样本过于稀疏而且与其他子任务没有太大区分性。因此，我们在对每个子任务，正样本仍然取该任务的正样本，负样本取其他子任务的正样本+少量曝光时间较短的负样本。这样既不至于各个子任务样本过于稀疏，也加大了样本的区分的难度，同时子任务之间也互相有区分性，使得各个子目标召回结果不至于大多雷同。
b. 序列特征self attention
特征上，我们使用了许多序列特征，如用户历史点赞的ugcid列表、用户历史完整播放的ugcid列表。Attention机制可以帮我们过滤掉序列中的噪音id，由于召回阶段没有item侧的信息，我们采用的是self attention。离线的实验表明，使用了self attention机制，离线的指标recall@10、recall@50等有比较明显的提升。

c. 特征shortcut
考虑到不同子目标对特征有不同的倾向，如点唱子目标中，伴奏id（songid）的作用就比较重要，而关注子目标中作者id（touid）相对来说更重要点。为了体现不同特征对不同子目标的重视。我们在做各个子目标的item embedding的时候，对某些特征做了shortcut，比如点唱子目标，我们在item 塔的中间层，重新concat了songid 的embedding，再生成最后的item embedding。事实证明这一改进对最后的效果正向提升比较明显。

d. 所有子目标共用user embdding
初始的多目标dssm每个任务生成各自的user和item embedding，然而，通过我们离线训练打印出来的user embedding我们发现，用户的各个embedding之间没有太大区别，原因可能是大部分用户在很多子目标（如点唱、关注）的正样本非常稀疏，这就使得那么正样本非常少的子目标的embedding在当前目标上难以得到训练，尤其是其user embedding。因此，我们最后采用了所有任务共用一个user embedding，而item embedding则仍是每个子目标各自生成。一方面因为item侧的稀疏性并不是那么严重，另一方面，这里item侧的负责学习各个子目标的差异，使得各个item在不同子目标的embedding差异化，上文的特征shortcut也是基于此目的。

e. 用户塔拆分成多塔融合
考虑到每个用户的活跃度不一致以及优化冷启动，同时，基于用户基础属性和用户正向序列变动不大的问题，我们引入了用户的负向序列。我们用户侧的特征包括用户正向行为序列、用户负向行为序列、用户基础属性这三部分。然后每部分会单独构成一个塔生成embedding，最后以当前输出的embedding生成一个gate来加权融合三个embedding向量来生成最后的user embedding。
